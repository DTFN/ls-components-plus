"use strict";var q=Object.defineProperty;var f=(v,i)=>q(v,"name",{value:i,configurable:!0});Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const r=require("vue"),g=require("../../util/index.cjs");function Y(v){const i=r.ref([]),d=r.ref({}),A=r.ref(16),m=r.ref(!1),p=r.ref({}),z=r.ref("hasChildren"),x=r.ref("children"),L=r.ref(!1),h=r.getCurrentInstance(),R=r.computed(()=>{if(!v.rowKey.value)return{};const a=v.data.value||[];return N(a)}),I=r.computed(()=>{const a=v.rowKey.value,e=Object.keys(p.value),t={};return e.length&&e.forEach(n=>{if(p.value[n].length){const o={children:[]};p.value[n].forEach(u=>{const s=g.getRowIdentity(u,a);o.children.push(s),u[z.value]&&!t[s]&&(t[s]={children:[]})}),t[n]=o}}),t}),N=f(a=>{const e=v.rowKey.value,t={};return g.walkTreeNode(a,(n,o,u)=>{const s=g.getRowIdentity(n,e);Array.isArray(o)?t[s]={children:o.map(K=>g.getRowIdentity(K,e)),level:u}:m.value&&(t[s]={children:[],lazy:!0,level:u})},x.value,z.value),t},"normalize"),w=f((a=!1,e=(t=>(t=h.store)==null?void 0:t.states.defaultExpandAll.value)())=>{var t;const n=R.value,o=I.value,u=Object.keys(n),s={};if(u.length){const K=r.unref(d),T=[],S=f((l,y)=>{if(a)return i.value?e||i.value.includes(y):!!(e||l!=null&&l.expanded);{const c=e||i.value&&i.value.includes(y);return!!(l!=null&&l.expanded||c)}},"getExpanded");u.forEach(l=>{const y=K[l],c={...n[l]};if(c.expanded=S(y,l),c.lazy){const{loaded:b=!1,loading:E=!1}=y||{};c.loaded=!!b,c.loading=!!E,T.push(l)}s[l]=c});const j=Object.keys(o);m.value&&j.length&&T.length&&j.forEach(l=>{const y=K[l],c=o[l].children;if(T.includes(l)){if(s[l].children.length!==0)throw new Error("[ElTable]children must be an empty array.");s[l].children=c}else{const{loaded:b=!1,loading:E=!1}=y||{};s[l]={lazy:!0,loaded:!!b,loading:!!E,expanded:S(y,l),children:c,level:""}}})}d.value=s,(t=h.store)==null||t.updateTableScrollY()},"updateTreeData");r.watch(()=>i.value,()=>{w(!0)}),r.watch(()=>R.value,()=>{w()}),r.watch(()=>I.value,()=>{w()});const M=f(a=>{i.value=a,w()},"updateTreeExpandKeys"),C=f((a,e)=>{h.store.assertRowKey();const t=v.rowKey.value,n=g.getRowIdentity(a,t),o=n&&d.value[n];if(n&&o&&"expanded"in o){const u=o.expanded;e=typeof e>"u"?!o.expanded:e,d.value[n].expanded=e,u!==e&&h.emit("expand-change",a,e),h.store.updateTableScrollY()}},"toggleTreeExpansion"),_=f(a=>{h.store.assertRowKey();const e=v.rowKey.value,t=g.getRowIdentity(a,e),n=d.value[t];m.value&&n&&"loaded"in n&&!n.loaded?O(a,t,n):C(a,void 0)},"loadOrToggle"),O=f((a,e,t)=>{const{load:n}=h.props;n&&!d.value[e].loaded&&(d.value[e].loading=!0,n(a,t,o=>{if(!Array.isArray(o))throw new TypeError("[ElTable] data must be an array");d.value[e].loading=!1,d.value[e].loaded=!0,d.value[e].expanded=!0,o.length&&(p.value[e]=o),h.emit("expand-change",a,!0)}))},"loadData");return{loadData:O,loadOrToggle:_,toggleTreeExpansion:C,updateTreeExpandKeys:M,updateTreeData:w,normalize:N,states:{expandRowKeys:i,treeData:d,indent:A,lazy:m,lazyTreeNodeMap:p,lazyColumnIdentifier:z,childrenColumnName:x,checkStrictly:L}}}f(Y,"useTree");exports.default=Y;
