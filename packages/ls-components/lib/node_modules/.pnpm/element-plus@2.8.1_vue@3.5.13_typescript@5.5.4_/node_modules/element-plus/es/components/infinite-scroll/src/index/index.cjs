"use strict";var D=Object.defineProperty;var f=(e,t)=>D(e,"name",{value:t,configurable:!0});Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const g=require("vue"),H=require("../../../../../../../../@vue_shared@3.5.13/node_modules/@vue/shared/dist/shared.esm-bundler/index.cjs"),N=require("../../../../utils/dom/position/index.cjs"),O=require("../../../../utils/error/index.cjs"),q=require("../../../../utils/dom/scroll/index.cjs"),p=require("../../../../../../../../lodash-es@4.17.21/node_modules/lodash-es/throttle/index.cjs"),r="ElInfiniteScroll",h=50,S=200,m=0,w={delay:{type:Number,default:S},distance:{type:Number,default:m},disabled:{type:Boolean,default:!1},immediate:{type:Boolean,default:!0}},T=f((e,t)=>Object.entries(w).reduce((o,[n,i])=>{var u,s;const{type:d,default:l}=i,a=e.getAttribute(`infinite-scroll-${n}`);let c=(s=(u=t[a])!=null?u:a)!=null?s:l;return c=c==="false"?!1:c,c=d(c),o[n]=Number.isNaN(c)?l:c,o},{}),"getScrollOptions"),y=f(e=>{const{observer:t}=e[r];t&&(t.disconnect(),delete e[r].observer)},"destroyObserver"),F=f((e,t)=>{const{container:o,containerEl:n,instance:i,observer:u,lastScrollTop:s}=e[r],{disabled:d,distance:l}=T(e,i),{clientHeight:a,scrollHeight:c,scrollTop:b}=n,A=b-s;if(e[r].lastScrollTop=b,u||d||A<0)return;let E=!1;if(o===e)E=c-(a+b)<=l;else{const{clientTop:L,scrollHeight:_}=e,C=N.getOffsetTopDistance(e,n);E=b+a>=C+L+_-l}E&&t.call(i)},"handleScroll");function v(e,t){const{containerEl:o,instance:n}=e[r],{disabled:i}=T(e,n);i||o.clientHeight===0||(o.scrollHeight<=o.clientHeight?t.call(n):y(e))}f(v,"checkFull");const I={async mounted(e,t){const{instance:o,value:n}=t;H.isFunction(n)||O.throwError(r,"'v-infinite-scroll' binding value must be a function"),await g.nextTick();const{delay:i,immediate:u}=T(e,o),s=q.getScrollContainer(e,!0),d=s===window?document.documentElement:s,l=p.default(F.bind(null,e,n),i);if(s){if(e[r]={instance:o,container:s,containerEl:d,delay:i,cb:n,onScroll:l,lastScrollTop:d.scrollTop},u){const a=new MutationObserver(p.default(v.bind(null,e,n),h));e[r].observer=a,a.observe(e,{childList:!0,subtree:!0}),v(e,n)}s.addEventListener("scroll",l)}},unmounted(e){if(!e[r])return;const{container:t,onScroll:o}=e[r];t==null||t.removeEventListener("scroll",o),y(e)},async updated(e){if(!e[r])await g.nextTick();else{const{containerEl:t,cb:o,observer:n}=e[r];t.clientHeight&&n&&v(e,o)}}};exports.CHECK_INTERVAL=h;exports.DEFAULT_DELAY=S;exports.DEFAULT_DISTANCE=m;exports.SCOPE=r;exports.default=I;
