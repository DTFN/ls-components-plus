"use strict";var V=Object.defineProperty;var s=(d,v)=>V(d,"name",{value:v,configurable:!0});Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const f=require("vue"),O=require("../../util/index.cjs"),X=require("../../tokens/index.cjs"),Z=require("../events-helper/index.cjs"),D=require("../styles-helper/index.cjs"),$=require("../../../../../hooks/use-namespace/index/index.cjs"),ee=require("../../../../../../../../../lodash-es@4.17.21/node_modules/lodash-es/merge/index.cjs");function le(d){const v=f.inject(X.TABLE_INJECTION_KEY),q=$.useNamespace("table"),{handleDoubleClick:x,handleClick:_,handleContextMenu:R,handleMouseEnter:S,handleMouseLeave:j,handleCellMouseEnter:w,handleCellMouseLeave:H,tooltipContent:W,tooltipTrigger:A}=Z.default(d),{getRowStyle:B,getRowClass:F,getCellStyle:I,getCellClass:J,getSpan:P,getColspanRealWidth:Y}=D.default(d),G=f.computed(()=>d.store.states.columns.value.findIndex(({type:l})=>l==="default")),T=s((l,t)=>{const n=v.props.rowKey;return n?O.getRowIdentity(l,n):t},"getKeyOfRow"),k=s((l,t,n,z=!1)=>{const{tooltipEffect:L,tooltipOptions:h,store:M}=d,{indent:K,columns:g}=M.states,C=F(l,t);let N=!0;n&&(C.push(q.em("row",`level-${n.level}`)),N=n.display);const a=N?null:{display:"none"};return f.h("tr",{style:[a,B(l,t)],class:C,key:T(l,t),onDblclick:s(e=>x(e,l),"onDblclick"),onClick:s(e=>_(e,l),"onClick"),onContextmenu:s(e=>R(e,l),"onContextmenu"),onMouseenter:s(()=>S(t),"onMouseenter"),onMouseleave:j},g.value.map((e,o)=>{const{rowspan:m,colspan:i}=P(l,e,t,o);if(!m||!i)return null;const u=Object.assign({},e);u.realWidth=Y(g.value,i,o);const c={store:d.store,_self:d.context||v,column:u,row:l,$index:t,cellIndex:o,expanded:z};o===G.value&&n&&(c.treeNode={indent:n.level*K.value,level:n.level},typeof n.expanded=="boolean"&&(c.treeNode.expanded=n.expanded,"loading"in n&&(c.treeNode.loading=n.loading),"noLazyChildren"in n&&(c.treeNode.noLazyChildren=n.noLazyChildren)));const E=`${T(l,t)},${o}`,p=u.columnKey||u.rawColumnKey||"",b=Q(o,e,c),r=e.showOverflowTooltip&&ee.default({effect:L},h,e.showOverflowTooltip);return f.h("td",{style:I(t,o,l,e),class:J(t,o,l,e,i-1),key:`${p}${E}`,rowspan:m,colspan:i,onMouseenter:s(y=>w(y,l,r),"onMouseenter"),onMouseleave:H},[b])}))},"rowRender"),Q=s((l,t,n)=>t.renderCell(n),"cellChildren");return{wrappedRowRender:s((l,t)=>{const n=d.store,{isRowExpanded:z,assertRowKey:L}=n,{treeData:h,lazyTreeNodeMap:M,childrenColumnName:K,rowKey:g}=n.states,C=n.states.columns.value;if(C.some(({type:a})=>a==="expand")){const a=z(l),e=k(l,t,void 0,a),o=v.renderExpanded;return a?o?[[e,f.h("tr",{key:`expanded-row__${e.key}`},[f.h("td",{colspan:C.length,class:`${q.e("cell")} ${q.e("expanded-cell")}`},[o({row:l,$index:t,store:n,expanded:a})])])]]:(console.error("[Element Error]renderExpanded is required."),e):[[e]]}else if(Object.keys(h.value).length){L();const a=O.getRowIdentity(l,g.value);let e=h.value[a],o=null;e&&(o={expanded:e.expanded,level:e.level,display:!0},typeof e.lazy=="boolean"&&(typeof e.loaded=="boolean"&&e.loaded&&(o.noLazyChildren=!(e.children&&e.children.length)),o.loading=e.loading));const m=[k(l,t,o)];if(e){let i=0;const u=s((E,p)=>{E&&E.length&&p&&E.forEach(b=>{const r={display:p.display&&p.expanded,level:p.level+1,expanded:!1,noLazyChildren:!1,loading:!1},y=O.getRowIdentity(b,g.value);if(y==null)throw new Error("For nested data item, row-key is required.");if(e={...h.value[y]},e&&(r.expanded=e.expanded,e.level=e.level||r.level,e.display=!!(e.expanded&&r.display),typeof e.lazy=="boolean"&&(typeof e.loaded=="boolean"&&e.loaded&&(r.noLazyChildren=!(e.children&&e.children.length)),r.loading=e.loading)),i++,m.push(k(b,t+i,r)),e){const U=M.value[y]||b[K.value];u(U,e)}})},"traverse");e.display=!0;const c=M.value[a]||l[K.value];u(c,e)}return m}else return k(l,t,void 0)},"wrappedRowRender"),tooltipContent:W,tooltipTrigger:A}}s(le,"useRender");exports.default=le;
